---
title: "Take-home Exercise 3"
author: "Stefanie Felicia"
date: "10 June 2025"
date-modified: "last-modified"
format: html
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---

## 1.1 Objective

The purpose of this take-home exercise is to:

-   Evaluate and determine the necessary R packages needed for Shiny Application which are supported in R CRAN

-   Review my teammates' take-home exercise 2 and prepare storyboards to visualize our work together

-   Prepare and test specific R codes and ensure it returns the expected output

-   Select appropriate Shiny UI components for exposing the paremeters

### 1.2. The Libraries

```{r}
pacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, knitr, DT, stringr, cronologia, tidytext, dplyr)
```

### 1.3 The Data

```{r}
MC3 <- fromJSON("data/MC3_graph.json")
MC3_schema <- fromJSON("data/MC3_schema.json")
```

## 2.1 Data Analysis

::: panel-tabset
## Inspect Knowledge Graph Structure

Before preparing the data, we'll check the structure of the knowledge graph.

```{r}
glimpse(MC3)
```

Since the industry column is in list data type, we'll exclude the column since list data type isn't acceptable by `tbl_graph()`.

## 2.2 Extract Edges and Nodes Tables

The `as_tibble()` function is used to extract nodes and links tibble data frame from MC3 tibble data frame.

```{r}
mc3_nodes <- as_tibble(MC3$nodes) 
mc3_edges <- as_tibble(MC3$edges)
```

## 2.3 Initial EDA

We'll use `ExpCatViz()` from SmartEDA library to reveal frequency distribution of all categorical fields from mc3_nodes.

```{r}
ExpCatViz(data=mc3_nodes, col="lightblue")
```

## 2.4 Data Cleaning and Wrangling

The following steps are taken to clean the **nodes**:

-   Convert values in id into character data type

-   Exclude record with id thunique(c(mc3_edges_indexed\$fromat are missing

-   Exclude records with similar id values

-   Exclude *thing_collected* field

```{r}
mc3_nodes_cleaned <- mc3_nodes %>%   mutate(id = as.character(id)) %>%   filter(!is.na(id)) %>%   distinct(id, .keep_all = TRUE) %>%   select(-thing_collected)
```

Next, the following steps are taken to clean the **edges**:

-   Rename source *column* into *from_id* and *target* column into *to_id*

-   Convert values in *from_id* and *to_id* column into character data type

-   Exclude values in from_id and to_id that's not found in the id column from *mc3_nodes_cleaned*

-   Exclude records where *from_id* and *to_id*, or *from_id* or *to_id* is missing

```{r}
mc3_edges_cleaned <- mc3_edges %>%       rename(from_id = source,               to_id = target) %>%       mutate(across(c(from_id, to_id),                      as.character)) %>%       filter(from_id %in% mc3_nodes_cleaned$id,               to_id %in% mc3_nodes_cleaned$id) %>%       filter(!is.na(from_id), !is.na(to_id))
```

A new dataframe from the existing data frame (*mc3_nodes_cleaned*) and *.row_id* column is added which assigns unique row number to each row number (works like row index). Then we select *id* and .*row_id* columns whereas other columns are dropped.

```{r}
node_index_lookup <- mc3_nodes_cleaned %>%   mutate(.row_id = row_number()) %>%   select(id, .row_id)
```

Then from_id and to_id columns in mc_edges_indexed are converted it to integer indices. The rows with unmatched nodes are also dropped.

```{r}
mc3_edges_indexed <- mc3_edges_cleaned %>%   left_join(node_index_lookup,              by = c("from_id" = "id")) %>%   rename(from = .row_id) %>%   left_join(node_index_lookup,              by = c("to_id" = "id")) %>%   rename(to = .row_id) %>%   select(from, to, is_inferred, type) %>%   filter(!is.na(from) & !is.na(to))
```

Next, the node list will only include nodes that are used in the edge list and new indices are assigned

```{r}
used_node_indices <- sort(unique(c(mc3_edges_indexed$from, mc3_edges_indexed$to)))
mc3_nodes_final <- mc3_nodes_cleaned %>%   
  slice(used_node_indices) %>%   
  mutate(new_index = row_number())
```

The lookup is rebuild from old index to new index.

```{r}
old_to_new_index <- tibble(old_index = used_node_indices, new_index = seq_along(used_node_indices))
```

Then, we'll update edge indices to match new node table

```{r}
mc3_edges_final <- mc3_edges_indexed %>%   left_join(old_to_new_index,              by = c("from" = "old_index")) %>%   rename(from_new = new_index) %>%   left_join(old_to_new_index,              by = c("to" = "old_index")) %>%   rename(to_new = new_index) %>%   select(from = from_new, to = to_new,           is_inferred, type)
```

## 2.5 Build tidygraph Object

```{r}
mc3_graph <- tbl_graph(nodes = mc3_nodes_final,   edges = mc3_edges_final,   directed = TRUE)
```

```{r}
str(mc3_graph)
```

## 2.6 Visualize Knowledge Graph

Next, we'll set a seed to ensure reproducibility and visualize the knowledge graph.

```{r}
set.seed(1234)
ggraph(mc3_graph, 
       layout = "fr") +
  geom_edge_link(alpha = 0.3, 
                 colour = "gray") +
  geom_node_point(aes(color = `type`), 
                  size = 4) +
  geom_node_text(aes(label = type), 
                 repel = TRUE, 
                 size = 2.5) +
  theme_void()
```
:::

The analytical visualisation must be prepared by using R and appropriate R packages. The report must provide detail discussion and explanation of:

the data preparation process, the selection of data visualisation techniques used, and the data visualisation design and interactivity principles and best practices implemented.

Storyboard of Visualization

<https://giniceseah.netlify.app/posts/2021-07-31-storyboard/>
