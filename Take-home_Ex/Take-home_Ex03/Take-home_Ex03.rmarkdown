---
title: "Take-home Exercise 3"
author: "Stefanie Felicia"
date: "10 June 2025"
date-modified: "last-modified"
format: html
execute: 
  eval: true
  echo: true
  warning: false
  freeze: true
---



## 1.1 Objective

The purpose of this take-home exercise is to:

-   Evaluate and determine the necessary R packages needed for Shiny Application which are supported in R CRAN

-   Review my teammates' take-home exercise 2 and prepare storyboards to visualize our work together

-   Prepare and test specific R codes and ensure it returns the expected output

-   Select appropriate Shiny UI components for exposing the paremeters

### 1.2. The Libraries



```{r}
pacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, knitr, DT, stringr, cronologia, tidytext, dplyr)
```



### 1.3 The Data



```{r}
MC3 <- fromJSON("data/MC3_graph.json")
MC3_schema <- fromJSON("data/MC3_schema.json")
```



## 2.1 Data Analysis

::: {.panel-tabset}
## Inspect Knowledge Graph Structure

Before preparing the data, we'll check the structure of the knowledge graph.



```{r}
glimpse(MC3)
```



Since the industry column is in list data type, we'll exclude the column since list data type isn't acceptable by `tbl_graph()`.

## 2.2 Extract Edges and Nodes Tables

The `as_tibble()` function is used to extract nodes and links tibble data frame from MC3 tibble data frame.



```{r}
mc3_nodes <- as_tibble(MC3$nodes) 
mc3_edges <- as_tibble(MC3$edges)
```



## 2.3 Initial EDA

We'll use `ExpCatViz()` from SmartEDA library to reveal frequency distribution of all categorical fields from mc3_nodes.



```{r}
ExpCatViz(data=mc3_nodes, col="lightblue")
```



## 2.4 Data Cleaning and Wrangling

The following steps are taken to clean the **nodes**:

-   Convert values in id into character data type

-   Exclude record with id thunique(c(mc3_edges_indexed\$fromat are missing

-   Exclude records with similar id values

-   Exclude *thing_collected* field



```{r}
mc3_nodes_cleaned <- mc3_nodes %>%   mutate(id = as.character(id)) %>%   filter(!is.na(id)) %>%   distinct(id, .keep_all = TRUE) %>%   select(-thing_collected)
```



Next, the following steps are taken to clean the **edges**:

-   Rename source *column* into *from_id* and *target* column into *to_id*

-   Convert values in *from_id* and *to_id* column into character data type

-   Exclude values in from_id and to_id that's not found in the id column from *mc3_nodes_cleaned*

-   Exclude records where *from_id* and *to_id*, or *from_id* or *to_id* is missing



```{r}
mc3_edges_cleaned <- mc3_edges %>%       rename(from_id = source,               to_id = target) %>%       mutate(across(c(from_id, to_id),                      as.character)) %>%       filter(from_id %in% mc3_nodes_cleaned$id,               to_id %in% mc3_nodes_cleaned$id) %>%       filter(!is.na(from_id), !is.na(to_id))
```



A new dataframe from the existing data frame (*mc3_nodes_cleaned*) and *.row_id* column is added which assigns unique row number to each row number (works like row index). Then we select *id* and .*row_id* columns whereas other columns are dropped.



```{r}
node_index_lookup <- mc3_nodes_cleaned %>%   mutate(.row_id = row_number()) %>%   select(id, .row_id)
```



Then from_id and to_id columns in mc_edges_indexed are converted it to integer indices. The rows with unmatched nodes are also dropped.



```{r}
mc3_edges_indexed <- mc3_edges_cleaned %>%   left_join(node_index_lookup,              by = c("from_id" = "id")) %>%   rename(from = .row_id) %>%   left_join(node_index_lookup,              by = c("to_id" = "id")) %>%   rename(to = .row_id) %>%   select(from, to, is_inferred, type) %>%   filter(!is.na(from) & !is.na(to))
```



Next, the node list will only include nodes that are used in the edge list and new indices are assigned



```{r}
used_node_indices <- sort(unique(c(mc3_edges_indexed$from, mc3_edges_indexed$to)))
mc3_nodes_final <- mc3_nodes_cleaned %>%   
  slice(used_node_indices) %>%   
  mutate(new_index = row_number())
```



The lookup is rebuild from old index to new index.



```{r}
old_to_new_index <- tibble(old_index = used_node_indices, new_index = seq_along(used_node_indices))
```



Then, we'll update edge indices to match new node table



```{r}
mc3_edges_final <- mc3_edges_indexed %>%   left_join(old_to_new_index,              by = c("from" = "old_index")) %>%   rename(from_new = new_index) %>%   left_join(old_to_new_index,              by = c("to" = "old_index")) %>%   rename(to_new = new_index) %>%   select(from = from_new, to = to_new,           is_inferred, type)
```



## 2.5 Build tidygraph Object



```{r}
mc3_graph <- tbl_graph(nodes = mc3_nodes_final,   edges = mc3_edges_final,   directed = TRUE)
```

```{r}
str(mc3_graph)
```



## 2.6 Visualize Knowledge Graph

Next, we'll set a seed to ensure reproducibility and visualize the knowledge graph.



```{r}
set.seed(1234)
ggraph(mc3_graph, 
       layout = "fr") +
  geom_edge_link(alpha = 0.3, 
                 colour = "gray") +
  geom_node_point(aes(color = `type`), 
                  size = 4) +
  geom_node_text(aes(label = type), 
                 repel = TRUE, 
                 size = 2.5) +
  theme_void()
```


:::

The analytical visualisation must be prepared by using R and appropriate R packages. The report must provide detail discussion and explanation of:

the data preparation process, the selection of data visualisation techniques used, and the data visualisation design and interactivity principles and best practices implemented.

Storyboard of Visualization

<https://giniceseah.netlify.app/posts/2021-07-31-storyboard/>

# app.R ---------------------------------------------------------------

library(shiny) library(jsonlite) library(dplyr) library(purrr) library(visNetwork) library(DT) library(tidygraph) library(ggraph) library(patchwork) library(grid)

# ── 1. master colour map ---------------------------------------------

legend_cols \<- c( Person = "#1b9e77", Vessel = "#d95f02", Organization = "#7570b3", Relationship = "#e7298a", Group = "#e6ab02", Location = "#66a61e" )

# ── 2. load + preprocess ---------------------------------------------

graph \<- read_json("Data/MC3_graph.json", simplifyVector = TRUE)

events_df \<- graph\$nodes %\>% filter(type == "Event", !is.na(timestamp)) %\>% mutate(date = as.Date(timestamp)) %\>% filter(date \>= as.Date("2040-10-01"), date \<= as.Date("2040-10-15"))

min_date \<- min(events_df$date)
max_date <- max(events_df$date)

nodes_all \<- graph\$nodes %\>% mutate(category = if_else(type == "Relationship", "Relationship", sub_type)) %\>% filter(category %in% names(legend_cols)) %\>% mutate(color = legend_cols\[category\])

edges_all \<- graph\$edges %\>% transmute(from = source, to = target, type = type, \# 'sent', 'received', etc. arrows = "to")

edges_all \<- edges_all %\>% left_join(events_df %\>% select(id, date), by = c("from" = "id")) %\>% rename(date_from = date) %\>% left_join(events_df %\>% select(id, date), by = c("to" = "id")) %\>% rename(date_to = date) %\>% mutate(event_date = coalesce(date_from, date_to)) %\>% select(-date_from, -date_to)

# ── 3. UI -------------------------------------------------------------

ui \<- fluidPage( titlePanel("MC3 Entity & Relationship Network"), sidebarLayout( sidebarPanel( selectInput("classes", "Show node classes:", choices = names(legend_cols), selected = c("Person", "Vessel"), multiple = TRUE), sliderInput("dateRange", "Event-date window:", min = min_date, max = max_date, value = c(min_date, max_date), timeFormat = "%Y-%m-%d"), checkboxInput("isolates", "Keep isolated nodes", FALSE), tags$hr(), tags$h5("Legend"), \## dynamic legend based on legend_cols ------------------------- tagList(lapply(names(legend_cols), function(cat) { tags$div(style="display:flex; align-items:center; margin-bottom:4px;",
                 tags$span(style=sprintf( "display:inline-block;width:14px;height:14px;border-radius:50%%;\
background:%s;margin-right:6px;", legend_cols\[cat\])), tags\$span(cat) ) })), width = 3 ), mainPanel( tabsetPanel(id = "tabs", tabPanel("Interactive Network", visNetworkOutput("net", height = "800px"), br(), tabsetPanel(type = "tabs", tabPanel("Nodes", DTOutput("nodes_table")), tabPanel("Edges", DTOutput("edges_table")) ) ), tabPanel("Daily Communication Graph", plotOutput("dailyPlot", height = "1400px") ) ) ) ) )

# ── 4. Server ---------------------------------------------------------

server \<- function(input, output, session) {

edges_date \<- reactive({ edges_all %\>% filter(is.na(event_date) \| (event_date \>= input$dateRange[1] &
                  event_date <= input$dateRange\[2\])) })

nodes_r \<- reactive({ req(input$classes)
    ids <- unique(c(edges_date()$from, edges_date()$to))
    n <- nodes_all %>%
      filter(category %in% input$classes, id %in% ids)

```         
if (!isTRUE(input$isolates)) {
  n <- n %>% filter(id %in% ids)
}
n
```

})

edges_r \<- reactive({ ids \<- nodes_r()\$id edges_date() %\>% filter(from %in% ids & to %in% ids) })

\# ---- visNetwork ---------------------------------------------------- output\$net \<- renderVisNetwork({ net_nodes \<- nodes_r() %\>% transmute(id, label, group = category, color) net_edges \<- edges_r() %\>% transmute(from, to, arrows = "to", label = type)

```         
if (nrow(net_nodes) == 0)
  return(visNetwork(data.frame(), data.frame()))

visNetwork(net_nodes, net_edges) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visPhysics(stabilization = FALSE)
```

})

\# ---- Daily graph (still Person ↔ Vessel) -------------------------- \# --------------------------------------------------------------------- \# Daily communication graph (interactive with class selection) \# --------------------------------------------------------------------- \# --------------------------------------------------------------------- \# Daily communication graph – responds to ANY mix of classes chosen \# --------------------------------------------------------------------- daily_plot \<- reactive({

```         
keep_cls <- input$classes
if (length(keep_cls) < 2) return(NULL)       # need at least two classes

## 1  communication edges inside the date window ---------------------
e_full <- edges_date() %>%
  filter(type %in% c("sent","received"),
         !is.na(event_date))
if (nrow(e_full) == 0) return(NULL)

## 2  build sender → receiver pairs via the comm node ---------------
es <- e_full %>% filter(type == "sent")      %>%
  transmute(comm = to,   sender = from,  event_date)
er <- e_full %>% filter(type == "received")  %>%
  transmute(comm = from, receiver = to,  event_date)

pv_edges <- inner_join(es, er,
                       by = c("comm","event_date")) %>%
  transmute(from = sender, to = receiver, event_date)

if (nrow(pv_edges) == 0) return(NULL)

## 3  look up the categories of each endpoint -----------------------
cat_lookup <- nodes_all %>% select(id, category)

pv_edges <- pv_edges %>%
  left_join(cat_lookup, by = c("from" = "id")) %>%
  rename(cat_from = category) %>%
  left_join(cat_lookup, by = c("to" = "id")) %>%
  rename(cat_to   = category) %>%
  filter(cat_from %in% keep_cls,                   # keep ONLY selected classes
         cat_to   %in% keep_cls)

if (nrow(pv_edges) == 0) return(NULL)

## 4  node table limited to kept classes ----------------------------
node_ids <- unique(c(pv_edges$from, pv_edges$to))
pv_nodes <- nodes_all %>%
  filter(id %in% node_ids, category %in% keep_cls) %>%
  select(id, label, category)

## 5  one facet per day ---------------------------------------------
plots <- lapply(sort(unique(pv_edges$event_date)), function(d){
  
  g <- tbl_graph(
    nodes = pv_nodes %>% filter(id %in% c(
      pv_edges$from[pv_edges$event_date == d],
      pv_edges$to  [pv_edges$event_date == d] )),
    edges = pv_edges %>% filter(event_date == d),
    directed = TRUE)
  
  ggraph(g, layout = "fr") +
    geom_edge_link(
      arrow       = grid::arrow(length = grid::unit(2, "mm")),
      edge_colour = "#666666", edge_alpha = 0.5) +
    geom_node_point(aes(color = category), size = 3) +
    geom_node_text(aes(label = label), repel = TRUE, size = 3) +
    scale_color_manual(values = legend_cols, breaks = names(legend_cols)) +
    ggtitle(as.character(d)) +
    theme_void() +
    theme(legend.position = "none",
          plot.title = element_text(size = 10, hjust = 0.5),
          plot.margin     = margin(t = 10, r = 5, b = 20, l = 5))
})

wrap_plots(plots, ncol = 2)
```

})

output\$dailyPlot \<- renderPlot({ daily_plot() }, res = 96)

\# ---- Tables -------------------------------------------------------- output\$nodes_table \<- renderDT( nodes_r() %\>% select(id, label, category, color), options = list(pageLength = 10), rownames = FALSE)

output\$edges_table \<- renderDT( edges_r() %\>% select(from, to, type, event_date), options = list(pageLength = 10), rownames = FALSE) }

shinyApp(ui, server)

