{
  "hash": "1bff50fef68675859b6fb43e0b23e904",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Hands-on Exrcise 8a\"\nauthor: \"Stefanie Felicia\"\ndate: \"11 June 2025\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n## Getting Started\n\nObjective of this exercise:\n\n-   Plot functional and truthful choropleth maps using *tmap*\n\n## Import Libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(sf, tmap, tidyverse)\n```\n:::\n\n\n\nThe libraries used in this exercise would be:\n\n-   sf: support for simple feature access, standardized way to encode and analyze spatial vector data\n\n-   tmap: used to draw thematic maps\n\n-   tidyverse: inclusive of readr. tidyr and dplyr package\n\n## The Data\n\nIn this exercise, we'll use the Master \\[;am 2014 Subzone Boundary (ESRI shapefile format) from dataset <a href=\"https://data.gov.sg/\">data.gov.sg</a> and Singapore Residents by Planning Area/Subzone, Age Group, Sex and Type of Dwelling, June 2011-2020 dataset (csv file) from <a href=\"https://www.singstat.gov.sg/\">Department of Statistics, Singapore</a>.\n\n### Import Geospatial Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz <- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `C:\\stefanie-fel\\ISSS608-VAA\\Hands-on_Ex\\Hands-on_Ex08\\data\\geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n```\n\n\n:::\n:::\n\n\n\n::: callout-note\n-   uses the st_read() function from sf library to import the shapefile into R\n:::\n\nWe'll examine the content fo the data frame by calling the variable\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n```\n\n\n:::\n:::\n\n\n\n### Import Attribute Data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata <- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n```\n:::\n\n\n\n## Data Preparation\n\nWe want to prepare the data table with 2020 values. We want the data table to include the following columns: PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL DEPENDENCY, where:\n\n-   YOUNG: age from 0 to 4 - 20 to 24\n\n-   ECONOMY ACTIVE: age from 25 to 29 - 60 to 64\n\n-   AGED: age 65 and above\n\n-   TOTAL: frequency of all age group\n\n-   DEPENDENCY: ratio between young + aged / economy active group\n\nFirst, we'll use pivot_wider to trasnform long data format to wide format, whereas mutate(), filter(), group_by() and select() is used to manipulate and filter data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata %>%\n  filter(Time == 2020) %>%\n  group_by(PA, SZ, AG) %>%\n  summarise(`POP` = sum(`Pop`)) %>%\n  ungroup() %>%\n  pivot_wider(names_from=AG, \n              values_from=POP) %>%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %>%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%>%\nmutate(`AGED`=rowSums(.[16:21])) %>%\nmutate(`TOTAL`=rowSums(.[3:21])) %>%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %>%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n```\n:::\n\n\n\nBefore performing georelational join, we will convert the values of PA and SZ columns to uppercase, as it is currently in uppercase and lowercase. There will be mismatch in the join if they don't have the same format.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npopdata2020 <- popdata2020 %>%\n  mutate(across(c(PA, SZ), toupper)) %>%\n  filter(`ECONOMY ACTIVE` > 0)\n```\n:::\n\n\n\nNext, we use left_join() to join the geographical data and attribute table using SUBZONE_N and SZ as common identifier.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmpsz_pop2020 <- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n```\n:::\n\n\n\nNext, write_rds will be ysed to save the R object into file in binary format (RDS).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")\n```\n:::\n\n\n\n## Choropleth Mapping Geospatial Data with tmap\n\nThere are two ways of creating thematic maps with tmap:\n\n-   Plotting using qtm()\n\n-   Plotting customization thematic map using tmap elements\n\n### Plotting Chropleth Map using qtm()\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note title=\"What the code does\"}\n-   tmap_mode() with \"plot\" option will create static map. Interactive mode is created using \"view\" option\n\n-   fill argument is used to map the attribute (i.e. DEPENDENCY)\n:::\n\n## Create Custom Chropleth Map using tmap's element\n\nWe can create custom choropleth map as it gives us more flexibility than qtm(). First, we can use tm_shape and followed by one or more layer element (i.e. tm_fill() and tm_polygons()).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n\nNext, we can show geographical distribution of selected variable by planning subzone in the choropleth map by assigning Dependency to tm_ploygons().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note title=\"Important points\"}\n-   The default interval binning useed to draw choropleth map is called \"pretty\"\n\n-   By default, missing values will be shaded in grey\n\n-   The default color scheme is Y1OrRd\n:::\n\nWe can also draw the choropleth map using tm_fill alone, but the difference from tm_polygons() is that it combines tm_fill and tm_border(). In this example, we'll use tm_fill to graph the choropleth map.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n\nIf we use tm_polygons(), we can also control the border by using the tm_borders().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\") +\n  tm_borders(lwd = 0.01,  \n             fill_alpha = 0.1)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n::: {.callout-note title=\"What the code does\"}\n-   alpha argument is sued to define transparency (between 0, which is totally transparent and 1, which is not transparent).\n\n-   col define border color\n\n-   lwd defines the line width (default is 1)\n\n-   lty defines border line type (default is \"solid\")\n:::\n\nNext, we'll add data classification method using tmap. The function has a few data classification method: *fixed*, *sd*, *equal*, *pretty* (default), *quantile*, *kmeans*, *hclust*, *bclust*, *fisher*, and *jenks.* In this example, we use quantile data classification with 5 classes (added into fill.scale of the tm_polygons function).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\nHere, we'll use the equal data classification.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nAs we can see, depending on which data classification method used, we can arrive at different looking graphs.\n\nWe can experiment with different number of classes. In this example, we'll use 2 classes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 2)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nWhereas, a 6 classes will look like this\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 6)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\nA 20 classes look like below\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 20)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n## Plot Choropleth Map with Custome Break\n\nFor all built-in styles, category breaks are computed internally, but we can override the default by setting breakpoints (breaks argument in tm_fill()). They also need to include maximum and minimum, this means that in order to end up with n categories, n+1 elements must be specified in the *breaks* option (the values must be in increasing order). But first, let's check the descriptive statistics of dependency column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(mpsz_pop2020$DEPENDENCY)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1111  0.7147  0.7867  0.8585  0.8763 19.0000      92 \n```\n\n\n:::\n:::\n\n\n\nNext, we'll set the break point at 0.6, 0.7, 0.8 and 0.9. and the minimum at 0 and maximum at 100.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n\n\n## Color Scheme\n\nColor scheme in tmap uses RColorBrewer package, but we can change the color using tm_scale_intervals() function in which we can assign preferred color to values argument of the function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n\nWe can reverse the color shading by adding \"-\" in values:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"-brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\n\n## Map Layouts\n\nMap layouts refers to the combination of all map elements (i.e. objects to be mapped, title, scale bar, compass, margin and aspects ratio).\n\n### Map Legend\n\ntm_legend() options are provided to change placement, format and appearance of the legend.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5,\n        values = \"brewer.greens\"),\n      fill.legend = tm_legend(\n        title = \"Dependency ratio\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n\n\n### Map Style\n\ntmap_style() is used to change the layout of graph (similar to theme in ggplot2). In this example, we'll change the choropleth map to a \"classic\" style.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n:::\n\n\n\n### Cartographic Furniture\n\ntmap also provide argument to draw other map furniture (i.e. compass, scale bar and grid line) by using tm_compass(), tm_scale_bar() and tm_grid() respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\n\n## Graphing Multiple Choropleth Maps\n\nWe can create small multiple maps in tmap by using:\n\n-   Assigning multiple values to at least one of aesthetic arguments\n\n-   Defining group-by variable in tm_facets()\n\n-   Creating multiple stand-alone maps with tmap_arrange()\n\n### Method #1: Assigning multiple values to at least one of aesthetic arguments\n\nUsing ncols in tm_fill() can be used to draw multiple choropleth maps\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\n\n### Method #2: Defining group-by variable in tm_facets()\n\nMultiple small choropleth maps can be created using tm_facets()\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n\n### Method #3: Creating multiple stand-alone maps with tmap_arrange()\n\nWe can create multiple multiple stand-alone maps using tmap_arrange() to create small chropleth maps.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nyoungmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap <- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n## Mapping Spatial Object Meeting a Selection Criterion\n\nInstead of creating multiple small choropleth map like above, we can also use selection function to map spatial object meeting the selection criterion.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)\n```\n\n::: {.cell-output-display}\n![](Hands-on_Ex08a_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "Hands-on_Ex08a_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}