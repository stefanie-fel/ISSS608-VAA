{
  "hash": "4efa13ff248697f6f41212ba31a3b438",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"In-class_Ex01\"\nauthor: \"Stefanie Felicia\"\ndate: \"May, 17 2025\"\ndate-modified: \"last-modified\"\nexecute: \n  eval: true\n  echo: true\n  warning: false\n  freeze: true\n---\n\n\n\n## Getting Started\n\nObjective of this exercise:\n\n-   Split knowledge graph of mini case 1 into nodes and edges tibble data frame\n\n-   Tidy nodes and edges tibble data frame for conforming into tidygraph's requirements\n\n-   Create tidygraph object using tidied nodes and edges, and visualize them\n\n## Import Libraries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph)\n```\n:::\n\n\n\nThe libraries used in this exercise:\n\n-   tidyverse\n\n-   jsonlite: convert JSON data to R objects\n\n-   SmartEDA: help in getting the complete exploratory data analysis by running the function instead of writing long R codes.\n\n-   tidygraph\n\n-   ggraph\n\n## Import Data\n\nIn this example, we'll be using the dataset posted by VAST Challenge (Mini Case 1) and use jsonlite to extract the data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nkg <- fromJSON(\"data/MC1_graph.json\")\n```\n:::\n\n\n\n## Inspect Structure\n\nWe'll inspect the structure of the object using str() function\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(kg, max.level=1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 5\n $ directed  : logi TRUE\n $ multigraph: logi TRUE\n $ graph     :List of 2\n $ nodes     :'data.frame':\t17412 obs. of  10 variables:\n $ links     :'data.frame':\t37857 obs. of  4 variables:\n```\n\n\n:::\n:::\n\n\n\n## Extract Edges and Nodes Table\n\nThe `as_tibble()` function will be used to extract the nodes and links tibble data frames from object into 2 tibble data frame called nodes_tbl and edges_tbl.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnodes_tbl <- as_tibble(kg$nodes)\nedges_tbl <- as_tibble(kg$links)\n```\n:::\n\n\n\n## Data Exploration\n\nFirst, we'll check the frequency distribution of Edge Type field of edges_tbl.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data=edges_tbl, aes(y=`Edge Type`)) + geom_bar()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex01_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\nNext, we'll also check for the frequency distribution of Node Type from nodes_tbl.\n\n## Create Knowledge Graph\n\nNext, we'll ensure each of from node list to be mapped in the correct row number.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n id_map <- tibble(id=nodes_tbl$id, index=seq_len(nrow(nodes_tbl)))\n```\n:::\n\n\n\nThen we'll map the source and target IDs to row indices.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl <- edges_tbl %>%\n  left_join(id_map, by=c(\"source\" = \"id\")) %>%\n  rename(from=index) %>%\n  left_join(id_map, by=c(\"target\" = \"id\")) %>%\n  rename(to=index)\n```\n:::\n\n\n\nFilter any invalid edges (or unmatched edges)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges_tbl<- edges_tbl %>% \n  filter (!is.na(from), !is.na(to))\n```\n:::\n\n\n\nLastly, we'll use `tbl_graph()` to create tidygraph's graph object\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph <- tbl_graph(nodes = nodes_tbl, \n                   edges = edges_tbl, \n                   directed = kg$directed)\nclass(graph)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_graph\" \"igraph\"   \n```\n\n\n:::\n:::\n\n\n\n## Visualizing Knowledge Graph\n\nBefore visualizing the knowledge graph, we'll set the seed to ensure reproducibility.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(42)\n```\n:::\n\n\n\nNext we'll visualize and analyze the graph object\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph, layout = \"fr\") +\n  geom_edge_link(alpha = 0.3, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 4) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex01_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n\nThe graph looks messy and can be unclear to be used to identify patterns. So we can visualize sub-graph of knowledge graphs so that it's useful for us identify patterns.\n\n## Visualizing the Sub-graph\n\n### Step 1: filter edges to only \"Memberof\"\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph %>%\n  activate(edges) %>%\n  filter(`Edge Type` == \"Memberof\")\n```\n:::\n\n\n\n### Step 2: Extract only connected nodes (i.e. used in these edges)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nused_node_indices <- graph_memberof %>%\n  activate(edges) %>%\n  as_tibble() %>%\n  select(from, to) %>%\n  unlist() %>%\n  unique()\n```\n:::\n\n\n\n### Step 3: Keep only those nodes\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngraph_memberof <- graph_memberof %>%\n  activate(nodes) %>%\n  mutate(row_id = row_number()) %>%\n  filter(row_id %in% used_node_indices) %>%\n  select(-row_id)  # optional cleanup\n```\n:::\n\n\n\n### Plot the sub-graph\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggraph(graph_memberof, \n       layout = \"fr\") +\n  geom_edge_link(alpha = 0.5, \n                 colour = \"gray\") +\n  geom_node_point(aes(color = `Node Type`), \n                  size = 1) +\n  geom_node_text(aes(label = name), \n                 repel = TRUE, \n                 size = 2.5) +\n  theme_void()\n```\n\n::: {.cell-output-display}\n![](In-class_Ex01_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nNow, we can clearly see the relationship between musical group and person much easier compared to the knowledge graph.\n",
    "supporting": [
      "In-class_Ex01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}